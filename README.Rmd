---
output: github_document
editor_options: 
  chunk_output_type: console
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
library(dplyr)
library(sf)
minimal_mesh <- silicate::minimal_mesh
sf::st_crs(minimal_mesh) <- NA
inlandwaters <- silicate::inlandwaters
sf::st_crs(inlandwaters) <- NA

```

# area

<!-- badges: start -->
[![Lifecycle: experimental](https://img.shields.io/badge/lifecycle-experimental-orange.svg)](https://www.tidyverse.org/lifecycle/#experimental)
[![R build status](https://github.com/hypertidy/area/workflows/R-CMD-check/badge.svg)](https://github.com/hypertidy/area/actions)
<!-- badges: end -->

The goal of area is to calculate areas, allow control over how that happens, and illustrate how it works. 

Very much work in progress. 

Please, do not use this for your land surveying contract. 

## Installation

You can install the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("hypertidy/area")
```

## Straightforward tools

The area package is written to allow easy to use calculations for
developing packages. It's similar to the [traipse](https://CRAN.r-project.org/) package which was created to leverage the grouping mechanisms of the tidyverse for common tracking data calculations. (In time we will have calculation idioms that are seriously fast to run as well as they are easy to write.)

```{r area}
library(dplyr)
library(area)

calc_area <- function(df) {
 area <- df %>% 
  group_by(multipolygon_id, polygon_id, linestring_id) %>% 
  summarize(area = poly_area(cbind(x, y))) %>% 
  ungroup() #%>% 
  area %>%  mutate(area = area, 
                   hole = c(-1, 1)[(pmax(c(1, diff(multipolygon_id)), c(1, diff(polygon_id))) == 1) + 1])
}

df <- sfheaders::sf_to_df(minimal_mesh)
(mmarea <- calc_area(df))
sf::st_area(minimal_mesh)


df <- sfheaders::sf_to_df(silicate::inlandwaters)
calc_area(df) %>% summarize(area = sum(area * hole)) %>% pull(area)
sum(sf::st_area(sf::st_set_crs(silicate::inlandwaters, NA)))

```

## Straightforward? 

Well - ha ha - we will need some ease of use here, and some speed ups - but we aren't restricted to one in-memory format, we have the area of every component part to use as we wish (the grouping tells us about holes and multipolygons), and when we have the right tools we'll only be using R and C++. Oh and triangles composed of 3 points not 4. 


```{r triangles}
(a <- tri_area(mm_tri$P[t(mm_tri$T), ]))
sum(a)

## so we don't double count the hole
print(sum(mmarea$area[mmarea$hole > 0]))
```

The key motivation here is *flexibility*. 

---

## Code of Conduct

Please note that the area project is released with a [Contributor Code of Conduct](https://contributor-covenant.org/version/2/0/CODE_OF_CONDUCT.html). By contributing to this project, you agree to abide by its terms.
